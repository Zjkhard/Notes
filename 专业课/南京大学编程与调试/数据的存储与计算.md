#### 专业词汇

真值：数据在现实世界的表示

机器数：数据在计算机内部的表示

#### 真值与机器数

源码

```
#include <stdio.h>

int main()
{
    int ai = 100, bi = 2147483648, ci = -100;
    unsigned au = 100, bu = 2147483648, cu = -100;
    printf("ai=%d, bi=%d, ci=%d\n", ai, bi, ci);
    printf("au=%u, bu=%u, cu=%u\n", au, bu, cu);
    return 0;
}
```

汇编

objdump -S manu > manu.txt

```c++
0000000000400512 <main>:
  400512:	55                   	push   %rbp
  400513:	48 89 e5             	mov    %rsp,%rbp
  400516:	48 83 ec 20          	sub    $0x20,%rsp
  40051a:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%rbp) // ai =100
  400521:	c7 45 f8 00 00 00 80 	movl   $0x80000000,-0x8(%rbp)//bi=214783648
  400528:	c7 45 f4 9c ff ff ff 	movl   $0xffffff9c,-0xc(%rbp)//ci = -100
  40052f:	c7 45 f0 64 00 00 00 	movl   $0x64,-0x10(%rbp)  // au =100
  400536:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%rbp) //bu=214783648
  40053d:	c7 45 e8 9c ff ff ff 	movl   $0xffffff9c,-0x18(%rbp) //cu = -100
  400544:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  400547:	8b 55 f8             	mov    -0x8(%rbp),%edx
  40054a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40054d:	89 c6                	mov    %eax,%esi
  40054f:	bf 10 06 40 00       	mov    $0x400610,%edi
  400554:	b8 00 00 00 00       	mov    $0x0,%eax
  400559:	e8 b2 fe ff ff       	callq  400410 <printf@plt>
  40055e:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  400561:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400564:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400567:	89 c6                	mov    %eax,%esi
  400569:	bf 25 06 40 00       	mov    $0x400625,%edi
  40056e:	b8 00 00 00 00       	mov    $0x0,%eax
  400573:	e8 98 fe ff ff       	callq  400410 <printf@plt>
  400578:	b8 00 00 00 00       	mov    $0x0,%eax
  40057d:	c9                   	leaveq 
  40057e:	c3                   	retq   
  40057f:	90                   	nop
```

#### 数据存储的宽度

源码

```c++
#include <stdio.h>
void main()
{
    char a = 100;
    short b = 100;
    int c = 100;
    int d = 0x12345678;
    printf("a=%0xH, b=%0xH, c=%0xH, d=%0xH\n", a, b, c, d);
}
```

结论：

不同的数据类型占用的数值宽度是不一样的。

计算机按字节编址，每个地址单元只存储一个字节的宽度

大小端两种存放方式

在IA-32中，存储机制限制每次访存最多只能读写64位，即8个字节



#### 数据类型的转换

源码

```c++
#include <stdio.h>
int main()
{ 
    short si = -100; // 机器数1111111110011100  16进制 0xff9c   -100
    unsigned short usi = si;// 机器数1111111110011100  16进制 0xff9c   65436
    int i = usi;// 零扩展 机器数 00000000000000001111111110011100  0x0000ff9c   65436
    unsigned ui = usi;// 零扩展 机器数 00000000000000001111111110011100  0x0000ff9c  65436
    int il = si; //带符号扩展 机器数 11111111111111111111111110011100  0xffffff9c  -100
    unsigned uil = si; //带符号扩展 机器数 11111111111111111111111110011100  0xffffff9c  4294967196
    int i2 = 0x12345678;// 机器数 00010010001101000101011001111000    0x12345678  305419896
    short si2 = i2;// 机器数 0101011001111000  0x5678  22136
    unsigned short usi2 = i2; // 机器数 0101011001111000  0x5678  22136
    int i3 = si2; //机器数 00000000000000000101011001111000  0x00005678  22136
    int i4 = 4294967296; // 机器数 00000000000000000000000000000000 0x0  0
    printf("si = %d, usi =%u, i= %d, ui = %u, il = %d, uil =%u\n", si, usi, i, ui, il, uil);
    printf("i2 = %d, si2 = %d, usi2 = %u, i3=%d,i4=%d\n", i2, si2, usi2, i3, i4);
}
```

总结:

整数之间的转换：

1 等宽的两个整数之间的赋值，就是机器数上的复制操作

2 二进制位数短的整数赋值给长的整数时，需要考虑源操作数的数据类型。

   源操作数是带符号整数: 符号扩展操作

   源操作数是无符号整数：零扩展操作

3 二进制位数长的整数赋值给短的整数时， 截断操作

整数与浮点数之间的转换：

整数与浮点数之间的转换，是在编码格式上的转换

