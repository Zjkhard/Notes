#### 概念：

1：解决问题方法的效率跟数据的组织方式有关



2: 解决问题方法的效率也跟空间的利用率有关

##### 例1： PrintN

```c

// 循环
void printN(int N){
    for(int i=0;i<N;i++){
        printf("%d  ",i);
    }
    return;
}

//递归
void printN2(int N){
    if(N){
        printN2(N-1);
        printf("%d  ",N);
    }
    return;
}

int main(){
    printN(1000000);
    // printN2(1000000);
}
```



3: 解决问题方法的效率也跟算法的巧妙程度有关

##### 例3：多项式

编译: gcc -lm  main.c -o main  引用了数学函数库需要带上 -lm

```c
clock_t start, stop;
double duration;

double f(int n, double a[], double x)
{
    int i;
    double p = a[0];
    for (i = 1; i <= n; i++)
    {
        p += (a[i] * pow(x, i));
    }
    return p;
}

double f2(int n, double a[], double x)
{
    int i;
    double p = a[n];
    for (i = n; i > 0; i--)
    {
        p = a[i - 1] + x * p;
    }
    return p;
}

void testF()
{
    double a[] = {1, 2, 3, 4};
    // double res = f(4, a, 2);
    double res = f2(4, a, 2);
}

void test()
{
    start = clock();
    for (int i = 0; i < MAXK; i++)
    {
        testF();
    }

    stop = clock();
    duration = ((double)(stop - start));
    printf(" cost time = %f ", duration);
}
```

运行结果

```
[root@zjkStu1 Chapt0ne]# gcc -lm  main.c -o main
[root@zjkStu1 Chapt0ne]# ./main 
 cost time = 1190000.000000 
[root@zjkStu1 Chapt0ne]# gcc -lm  main.c -o main
[root@zjkStu1 Chapt0ne]# ./main 
 cost time = 110000.000000 
[root@zjkStu1 Chapt0ne]# 
```



抽象数据类型的定义

##### 例4：“矩阵”

![image-20211016130410505](https://gitee.com/zjkhard/note-img/raw/master/img/20211016130417.png)

​	

##### 什么是好的算法

时间复杂度

空间复杂度

![image-20211016144340363](https://gitee.com/zjkhard/note-img/raw/master/img/20211016144340.png)



算法：

##### 最大子列和

解法1：

```c
int MaxSubseqSum1(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for (i = 0; i < N; i++)
    {
        for (j = i; j < N; j++)
        {
            ThisSum = 0;
            for (k = i; k < j; k++)
            {
                ThisSum += A[k];
            }
            if (ThisSum > MaxSum)
            {
                MaxSum = ThisSum;
            }
        }
    }
    return MaxSum;
}

int MaxSubseqSum2(int A[], int N)
{
    int ThisSum, MaxSum = 0;
    int i, j, k;
    for (i = 0; i < N; i++)
    {
        ThisSum = 0;
        for (j = i; j < N; j++)
        {
            ThisSum += A[j];
            if (ThisSum > MaxSum)
            {
                MaxSum = ThisSum;
            }
        }
    }
    return MaxSum;
}

int MaxSubseqSum4(int A[], int N)
{
    int ThisSum = 0, MaxSum = 0;
    int i, j, k;
    for (i = 0; i < N; i++)
    {
        ThisSum += A[i];
        if (ThisSum > MaxSum)
        {
            MaxSum = ThisSum;
        }
        else if (ThisSum < 0)
        {
            ThisSum = 0;
        }
    }
    return MaxSum;
}

```

